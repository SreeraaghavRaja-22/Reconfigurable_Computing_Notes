Why is RC fast?
- RC implements custom circuits for an application 
	- Circuits can exploit massive amount of **parallelism**
	- VLIW/Superscalar Parallelism 
		- 5 instructions/cycle in best case (rarely occurs)

---
### Types of Parallelism
- **Bit-Level:**
	- Processor requires much longer than hardware for parallelism 
		- Processors are not optimized for Bit-Level parallelism 
- **Arithmetic Level Parallelism**
	- Hardware can take many less cycles to do arithmetic 
- **Pipeline Parallelism**
	- Deep parallelism
	- just doing multiple arithmetic operations at once 
	- Loop Unrolling 
- **Task-Level Parallelism**
	- Each box is a task 
	- All tasks execute in parallel 
	- Each task may have bit-level, wide, and deep parallelism 
- How to exploit parallelism? 
	- General idea
		- identify high-level tasks
	- Create circuit for each task 
		- Communication between tasks with buffers
	- How to create circuit for each task 
		- Want to exploit bit-level, arithmetic-level, and pipeline level parallelism 
		- Pipeline vs **systolic arrays** 
---
### Systolic Arrays
- Systolic Definition: 
	- the rhythmic contraction of the heart, especially the ventricles 
	- beating of heart = clock 
	- flow of blood = flow of data through computational components
	- "Data flows form memory in a rhythmic fashion, passing through many processing elements before it returns to memory."
	- Inputs arrive and go to output in a cycle 
		- Pipeline
	- **Systolic array is a type of Pipeline**
---
### Pipeline 
- Simple Example: 
	- Create DFG (data flow graph) for body loop
		- We need to represent **data dependencies**
	- Add pipeline stages for each level of the graph 
		- and find where they intersect (put registers there)
	- Add the hardware for each stage 
		- gets you a really simple pipeline 
			- gets really good performance 
			- never forget *delay registers* for pipeline 
- uP Performance Comparison
	- If each loop takes 10 instructions, then the CPI (cycles per instruction) = 1.5
		- Clk is also 10x faster than the FPGA
		- **Total cycles is then 100 * 10 * 1.5 = 1500 cycles** 
	- **RC Speedup**
		- First output took 4 cycles, then every subsequent output takes a single cycle
			- 99 + 4 = 103 cycles in total 
		- (1500 / 103) * (1/10) $\approx$ 1.5x the original speed 
	- What if the uP is 15x faster? 
		- RC Speedup is (1500/103) * (1/10) = 0.97x as faster
		- BUT
			- RC is much less power 
			- For low power processor, the RC will be faster 
			- RC could also be cheaper (depends on area size)
	- Simple Example Extended 
		- Improvement to Systolic Array 
			- Execute multiple iterations at once 
				- No data dependencies between iterations 
				- **Loop Unrolling** 
					- Compiler Optimization 
			- How much to enroll? 
				- Every additional iteration we do in parallel, requires 1 additional input to read from memory
				- **Unroll until you exhaust memory bandwidth of either the input or output**
					- usually the input bandwidth is the bottleneck 
				- For 64 Bit Example 
					- First iteration takes 24 bits 
						- each additional iteration takes 8 extra bits
						- 24 + 5(8) = 64
							- can unroll 5 more times
					- New performance
						- Unrolled pipeline requires
							- 4 cycles to fill pipeline, (100-6)/6 remaining iterations/cycles
								- 4 cycles to get 6 outputs (because we unrolled 5 times) = 6 iterations
							- ~20 cycles 
							- 1500/20 * 1/15
				- Performance with wider memories 
					- 128-bit bus
					- 1st iteration = 24 bits 
					- Bits for unrolling = 128 - 24 = 104
					- Each unrolling requires 8 bits 
					-  # of unrolling = 104/8 = 18
					- 14 iterations in parallel 
					- Total cycles to fill pipeline = 4 to fill pipeline + (100-14)/14 = ~11 cycles
					- Speedup (1500/11) * (1/15) = 9.1x
						- Doubling memory width increases speedup from 5x to 9.1x
					- Important Point 
						- performance of hardware often limited by memory bandwidth 
					- Common Mistakes 
						- Forgetting to add registers for values not used during a cycle 
							- Values "delayed" or passed on until needed ![[Pasted image 20251007161658.png]]