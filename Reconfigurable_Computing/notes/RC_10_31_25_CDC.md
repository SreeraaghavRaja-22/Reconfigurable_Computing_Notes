## Metastability 
- Metastability: the output is unstable for a given circuit 
- 2 situations cause metastability: 
	- 1) Asynchronous Signals
	- 2) Clock Domain Crossing 

## Clock Domain Crossing 
- Clock Domain Crossing: we go between two different clock domains for our design 
	- leads to metastability 
- Common Situation: the FPGA clock runs at a different frequency than external memory 
	- this could lead to metastability 
- Corner Case for CDC 
	- You can still achieve metastability when clocks at 2 different domains run at the same frequency if they are not **in phase**
		- Timing analyzer has to look at this 
- Synchronizers 
	- **Dual-Flop Synchronizer:** add a FF to the output node's output 
		- Pros: 
			- this is a simple solution to guarantee a stable signal (with sufficient probability)
		- Cons: 
			- cannot guarantee that the output is the correct value unless the source value is held constant for a sufficient time 
			- useful for 1 bit, but fails for signals that are multiple bits wide because of delays (could create a Random Number Generator)
				- Cannot guarantee that all bits will stabilize at the same time
	- **Mux Recirculation Synchronizer:** add a mux with a select between the FFs between both domains 
		- Select line is one bit (Send signal coming from control)
		- Pros: 
			- a lot of control added but we are guaranteed a stable signal 
			- useful for multiple bits
		- Cons: 
			- have to add a lot of control and have assumptions 
				- How long do we assert the send signal?
				- How long do we de-assert the send signal?
			- Not good to add logic between source and destination registers
	- **Handshake Synchronizer** 
		- 2 FSMs are connected to each other and connect to the source and destination registers
		- Pros: 
			- No guesswork involved 
			- No logic in between two synchronizers
			- Useful for multiple bits
		- Cons: 
			- More overhead involved compared to other synchronizers (because of 2 FSMs)
			- Need to synchronize signals going between 2 domains (use a dual flop synchronizer) 
	- **FIFO**
		- Useful for communicating across clock domains 
		- Has a write port and a read port 
			- Each port has a different clock 
			- Write Port: wr_clk, wr_data, wr_en, full)
				- write when FIFO is **not full**
			- Read Port: rd_clk, rd_data, rd_en, empty)
				- read when FIFO is **not empty**
		- Pros: 
			- good for high bandwidth and synchronization 
			- needs synchronization between the full and empty signals 
				- requires a dual-flop synchronizer
					- uses gray code encoding to allow for multibit synchronization with a dual flop synchonizer
						- Previous value or correct value but never wrong value. 
		- Cons: 
			- we need to make an FSM for the FIFO and need to understand the complexity behind a FIFO 
	- Constraints set by CDC
		- 1) false_path for every signal that crosses clock domains 
			- false_path: path that is ignored by the timing analyzer 
				- specify it as a false path 
			- issue: tells the timing analyzer to **ignore timing** for that specific path 
			- uses tools like SDC or XDC
		- 2) set_max_delay
			- set delay of signal for some reasonable amount 