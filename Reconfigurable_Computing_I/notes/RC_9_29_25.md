## Notes for Lab 2
- Transfer all files to the server 
---
## Optimization Problems 

### Introduction
- Why do we study optimization problems? 
- Every RC-tool related issue is an optimization problem 

### Time Complexity 
- Definition: 
	- Defines how execution time increases as input size increases
	- Interested in: 
		- **Big O Notation**
			- O(n) - linear
			- O($n^2$) - quadratic
			- O($2^n$) - exponential 
		- **P**
			- A problem is "in P" if it has a polynomial time solution
				- O(n), O($n^2$), O($n^3$)
		- **Undecidable** 
			- Provably impossible to solve 
				- Example: Halting problem 
					- "Will this other program ever actually finish"
					- Look up proof for this
		- **NP**
			- Does not mean "Not-Polynomial"
			- A NP problem has a non-deterministic polynomial time solution
				- algorithm where you can "predict a polynomial solution"
		- **NP-hard**
			- A problem is NP-hard if every problem in NP is reducible to it and reducible in polynomial time
				- Basically means that NP-hard problem is at least as hard as the hardest problems in NP 
				- **Hard** means **computational complexity**
		- **NP-Complete**
			- NP + NP-hard
			- Most interesting problems are NP-complete!!!
				- Traveling salesman, Subset sum, 0-1 knapsack, graph coloring, vertex cover
				- **Place and route, logic minimization, minimum resource scheduling, hw/sw partitioning, etc.** 
					- these are all NP complete problems in RC1
	- Does P = NP?
		- been studied for a long time 
		- never proven on way or another 
	- Why do we care? 
		- **Best known solutions for NP-Complete problems typically have complexity of O$\left(2^n\right)$, O(n!)**
			- Known as **intractable**, would take more than our lifetime to complete 
		- **If one NP-complete problem can be solved in polynomial time (is in P), then all NP-complete problems can be solved in polynomial time**
	- If we can find a polynomial time solution to an NP-complete RC problem: 
		- Can get an A
---
### Problem Classes
![[Pasted image 20251004193931.png]]

---

### More on Optimization 
- Informal Definition: 
	- Problem of finding the best solution from all possible solutions 
		- Typically involves finding the best solution for many possibilities 
- Possible solution: **exhaustive search** 
	- Check every possible solution and save the best one 
	- Works but very unoptimized 
- Many problems are NP-Complete
	- Not feasible to generate every solution 
		- If we have an NP-Complete problem with a complexity of O($2^n$), it would take forever to solve it 
- Problem: If most optimization problems are intractable, how do we solve them? 
	- Could use solution to any NP-complete problem 
		- However any NP-Complete problem can be reduced to any other NP-Complete problem 
	- But this doesn't really help
		- There is no known polynomial solution to any NP-Complete problem 
- Another solution: **Branch and Bound**
	- Idea: try to eliminate many possibilities without evaluating them 
	- How it works: 
		- Imagine a tree that represents all possible solutions 
		- Algorithm progressively builds tree
			- Maintains best found solution so far 
		- When considered a branch in the tree, determines best possible solution solution represented by a branch 
			- If branch can't be better than current best, don't bother looking for other solutions 
			- "Prunes" solution space 
	- Result: 
		- Pros:
			- Very often, can eliminate large percentage of possible solutions 
			- Still finds optimal solution 
			- Faster than exhaustive search (usually)
		- Cons: 
			- Still has exponential time complexity 
			- Not feasible for large input sizes 
---
## Heuristics 
- Another solution: 
	- Don't try to find the best solution 
	- Find a "good" solution quickly 
		- known heuristics 
- Good candidates for heuristics 
	- Map problem to other NP-complete problem, use heuristic for that problem 
		- Source of way too many publications 
	- Use generalized optimization problem heuristic 
		- Due to a large number of interesting optimization problems, research has introduced general heuristics that apply to all optimization problems 
		- Examples
			- **Hill Climbing**
				- Background: Graph of solution space 
					- x axis = all possible solutions 
					- y axis = quality of search 
						- Height of solution represents goodness
						- Peak = best solution
				- Informal Description
					- 1) Choose initial solution (S)
					- 2) Find neighboring solution (change 1 thing) = n
					- 3) If n is better than s (climbing the hill)
						- s = n, Repeat from 2)
					- 4) If all neighboring solutions worse than s
						- s is answer (s is a peak)
				- Example: Traveling Salesman 
					- 1) Find a solution (**Hamiltonian Cycle**)
					- 2) Swap 2 cities, if solution is better keep it else reject
					- 3) Repeat 2) until no improvement can be found
				- Limitation: 
					- Local Peaks are difficult to get out of, so we can't get the global peak solution 
					- Need way of escaping local peaks 
						- Have to accept some bad moves
			- **Simulated Annealing** 
				- Annealing is process of heating and cooling metals in order to improve strength 
				- Idea: Controlled heating and cooling of metal
					- When hot, atoms move around 
					- When cooled, atoms find configuration with lower internal energy 
						- i.e. makes metals stronger 
				- Analogy: 
					- Temperature: probability of accepting worse neighboring solution 
						- When temperature is high, likely to accept worse neighboring solutions (but may lead to better overall solution)
							- Analogous to atoms wandering around 
					- Cooling: shrinking probability of accepting worse solution
				- Informal Description
					- 1) Set initial temperature and probability **p**
					- 2) Find initial solution **s**
					- 3) Find neighboring solution **n**
					- 4) If **n is better than s**
						- s=n (always accept better solutions)
					- 5) If n is worse than s
						- Accept n with probability p
					- 6) Reduce "temperature" and p by some amount 
					- 7) If final temperature not reached, repeat form part 3)
					- 8) If final temperature reached, report best solution found 
				- Advantages 
					- can find near optimal solutions - escapes local maxima
				- Disadvantages
					- Takes a long time to find near optimal solution 
						- But still fast compared to algorithms 
					- Very sensitive to input parameters - must be configured well to get good results 
						- How long to run? 
							- Initial temperature/final temperature 
						- What should initial probability be? 
						- Cooling schedule 
							- How much to reduce temperature and probability at each step?
			- **Genetic Algorithms** 
				- Analogy:
					- Imitate Evolution - Survival of the Fittest 
						- Survivability represents quality of solution 
					- Gradually evolve a better solution by imitating genetic processes
				- Description:
					- Generates a "population" of solutions 
					- Selection chooses members of population (solutions) to survive by probability based of fitness function 
						- Bad solutions are less likely to "survive"
					- Reproduction combines attributes of selected population 
						- Crossover/Inheritance - Combines traits for each parent (solution)
						- Mutation - Random change to characteristic 
					- Repeat until solution has "evolved" to acceptable level 
				- Advantages: 
					- Can find near optimal solutions 
				- Disadvantages: 
					- Takes a long time to find near optimal solution 
						- faster than algorithms though
					- Very sensitive to input parameters - must be configured well to get good results 
						- How large should a population be? 
						- How does reproduction occur? 
						- How many generations should be considered? 
						- How much of each generation's population should be killed off? 
				- Same advantages/disadvantages as simulated annealing
			- **Ant Colony Optimization**
			- **Tabu Search**
			- **Stochastic Optimization**
			- **Gradient Descent**
### Why do we care? 
- Most RC Tool problems are NP-complete optimization problems 
- Know how to solve almost all tool problems 
	- Use Branch and Bound, Hill Climbing, Simulated Annealing, Genetic Algorithms, Ant Colony Optimization, Tabu Search, etc. 

---
