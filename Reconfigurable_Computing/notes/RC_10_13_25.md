### Importance of Memory Bandwidth 
- Performance with wider memories
	- 128-bit bus 
		- 14 iterations in parallel 
			- 64 extra bits/8 bits per iteration = 8 parallel iterations 
			- +6 unrolled iterations = 14 total parallel iterations 
		- Total cycles = 4 to fill pipeline + (100-14)/14 = ~11
	- Speedup (1500/11)\*(1/15) = 9.1x
		- Doubling memory width can increase speedup from 5x to 9.1x 
- Important Point 
	- Performance of hardware often limited by memory bandwidth 
	- Device limitations as well 
	- More bandwidth => more unrolling => more parallelism => **BIG SPEEDUP**
---
### Another Example 
- CODE
```
short b[1004], a[1000];
f(i=0; i < 1000; i++)
	a[i] = avg(b[i], b[i+1], b[i+2], b[i+3], b[i+4]);
```

- Steps
	- Build DFG for body of loop 
	- Add pipeline stages 
	- Map operations to hardware resources
	- Map operations to hardware resources 
		- Assume divide takes one cycle 
	- Determine maximum amount of unrolling 
		- Memory bandwidth = 128 bits/cycle 
	- Determine performance compared to a uP
		- Assume 15 instructions per second, CPI = 4.5, CLK = 15x faster than RC 
	- Another Example: 
		- divider takes 20 cycles but fully pipelined 
		- Calculate the effect on performance 
	- In pipelines, **performance** usually dominated by **throughput**, not **latency** 
	- Usually try to maximize for execution time 
---
### Dealing with Dependencies 
- **Dependence:** **operand 2** is dependent on **operand 1** when the input to **operand 2** is an output from **operand 1**
	- **Problem**
		- limits arithmetic parallelism, increases latency 
			- Can't execute op2 before op1
	- **Serious Problem**
		- FPGAs need parallelism to improve their performance
			- **Little parallelism = bad performance**
	- **Partial Solution**
		- **Parallelizing Transformations: **
			- tree height reduction 
			- Depth
				- optimize the depth (number of adders)
	- Simple Example w/ **inter-iteration dependency** 
		- Meaning: one iteration of a loop is dependent on the previous iteration of the loop
			- a\[1] is dependent on a\[0]
		- **Potential Problem for Pipelines** 
			- can't keep pipeline full 
		- **Fixes**
			- **Add pipeline stages => systolic array**
				- Only works if the loop is fully unrolled
				- Requires memory bandwidth
---
### Example Problem 
- Code
```
char b[1006];
for(i=0; i<1000;i++)
{
   acc = 0;
   for(j = 0;j < 6;j++)
   {
      acc += b[i+j];
   }
   a[i] = acc; 
}
```
- Steps 
	- Build DFG for inner loop (note dependencies)
	- Fully unroll inner loop (check to see if memory bandwidth allows)
		- assume bandwidth = 64 bits/cycle
	- Add pipeline stages 
	- Map operations to hardware resources 
	- Determine performance compared to uP
		- Assume 15 cycles per iteration, CPI = 1.5, Clk = 15x faster than RC
---
### Dealing with Control 
- IF Statements 
```
char b[1006], a[1000];
for(i=0;i<1000;i++)
	if(I % 2 == 0)
		a[I] = b[I] + b[I+1];
	else 
		a[I] = b[I+2] + b[I+3];
```
- **Problem:** If else statements stall out the pipeline 
	- have to wait for the result condition 
- **Solution:** convert control into computation 
	- **IF-Conversion:** we can use a mux and have our conditional be a select in the pipeline 
	- Inefficient but only solution
		- could be much more complex if we make the if body and else body happen both at the same time 
---
## Other Challenges 
- **Outputs can also limit unrolling** 
```
long b[1004], a[1000];
for(i=0, j=0;i<1000;i+=4, j++){
a[i] = b[j] + 10;
a[i+1] = b[j] * 23;
a[i+2] = b[j] - 12;
a[i+3] = b[j] * b[j];
}
```
- Example 
	- 4 outputs, 1 input
		- Each output is 32 bits 
		- Total output bandwidth for 1 iteration = 128 bits 
	- Memory bus = 128 bits 
		- can't unroll even though inputs only use 32 bits 
- **Requires streaming data to work well** 
	```
	for(i=0;i<4;i++)
		a[i] = b[i] + b[i+1];
	```
	- Same pipeline strategy as before, but **pipelining is wasted because small data stream**
		- Ex: communication across PCIx bus, network, etc.
		- Needs to be outweighed by parallelism on large data stream
	- **Point - pipelines work best with large amounts of repeated computation**
- **Memory bandwidth**
	- Values so far are "peak" values 
	- Can only be achieved if all input data stored sequentially (or in same rows) of memory
		- Often not the case
	- Example: 
		- Two-dimensional arrays 
		```
		long a[100][100], b[100][100]
		for(i=1;i<100;i++)
		{
		  for(j=1;j<100;j++)
		  {
		    a[i][j] = avg(b[i-1][j], b[i][j-1], b[i+1][j], b[i][j+1]);
		  }
		}
		```
		- Accessing things that are **not sequential in memory**
			- Harder to unroll and slower 
	- Example 2: 
		- Multiple Array Inputs
		 ```
		 long a[100][100], b[100], c[100];
		 for(i=0; i<100; i++){
		  a[i] = b[i] + c[i];
		 }
		 ```
		- b[] and c[] are stored in different locations 
			- Memory accesses may jump back and forth 
		- Possible solutions 
			- Use multiple memories or multiported memory (high cost)
				- just need to access b[] and c[] from different ports / stores of memory
			- Interleave data from b[] and c[] in memory (programming effort)
				- If no compiler support, requires manual rewrite 
				- Create our own custom memory
					- implementing different behavior from code
	- **Dynamic memory access patterns**
		```
		int f(int val){
		    long a[100], b[100], c[100]; 
		    for(i=0;i<100;i++){
		        a[i] = b[rand()%100] + c[i * val]
		    }
		}
		```
		- Sequence of addresses not known until **run time**
			- **not sequential addresses**
		- **Possible Solution**
			- something creative enough for a Ph.D thesis
	- **Pointer-based Data Structures**
		- Even if scanning through, data could be all over memory 
			- **very unlikely to be sequential** 
		- Can have **aliasing problems** 
			- limits optimization potential 
		- **Pointers are okay if they are used as an array**
		```
		  int f(int val){
			 long a[100], b[100];
			 long *p = b;
			 for(i=0;i<100;i++,p++){
			    a[i] = *p + 1;
			 }
		```
		- This is the same as 
		```
		// same as 
		 int f(int val){
			 long a[100], b[100];
			 for(i=0;i<100;i++){
			    a[i] = b[i] + 1;
			 }
		 }
		```
---
### Other Options 
- Try something completely different 
- Try slight variation 
	- Example: 3 inputs, but can only read 2 per cycle 
		- Example:
			- Break previous rules, use extra delay registers 
			- Send junk at first until you get first output
			- Get a valid output every 2 cycles
---
### General Overview
![[Pasted image 20251015231349.png]]
- The **pipeline** falls into the **datapath** part of this diagram