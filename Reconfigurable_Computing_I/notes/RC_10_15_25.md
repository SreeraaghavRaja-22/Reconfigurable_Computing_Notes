## High-Level Synthesis (Tools)

### Existing FPGA Tool Flow

- **Register-Transfer (RT) Synthesis**
  - Specify RT structure (muxes, registers, etc)
  - **Pro:** Allows *precise specification*
  - **Con:** *Time consuming, difficult, error prone*

---
### Motivation

- **Wouldn't it be nice to write high-level code?** 
	- Ratio of C to VHDL developers (10000:1 ?)
		- **Pros:** 
			- *Easier to specify*
			- Modular: separates function from architecture
				- *more portable code*
		- **Cons:**
			- *Slower hardware*
				- programmers could always beat compiler 
					- not the case anymore 
					- No high-level thing can replace RTL code really
		- *Hopefully,* high-level synthesis will catch up to RTL (manual effort)
			- *More challenging than compilation*
				- **Compilation:** *maps behavior* into *assembly instructions*
					- compiler knows the architecture already
				- **High-Level Synthesis:** *creates a custom architecture to execute behavior*
					- Huge hardware exploration space
					- Best solution may include microprocessors
					- Should handle any high-level code 
						- not all code is appropriate for hardware
---
### Steps for High-Level Synthesis 
- First, consider how to manually convert high-level code into circuit 
```C
acc = 0; 
for(i = 0; i < 128; i++)
	acc += a[i];
```
- Manual Steps
	- 1) Build **FSM** for controller 
		- Decompose code into states
	- 2) Build **datapath** based on FSM
		- Allocate resources for operations in each state 
		- Determine register inputs 
		- Add outputs 
		- Add control signals 
	- 3) Combine Controller and Datapath
		- identify tradeoffs between different datapaths and see what is most attractive
			- done by High-Level Synthesis
- High-Level Synthesis Steps 
	- **Scheduling:** Determining when to perform each operation 
	- **Resource Allocation:** Allocating resource for each operation
	- **Binding:** Mapping operations onto resources
---
### Basic Idea of High Level Synthesis 
- We take a high-level programming language like C/C++, SystemC, Java, Perl, Python, ImpulseC, etc. 
- We put that code through the **high-level synthesis tool**
- That tool outputs a **custom circuit** in either RTL VHDL description or as **low level as a bit file** 
---
### Main Steps for High-Level Synthesis 
- The **high-level synthesis tool** is very similar to a **compiler** 
- Front-End
	- 1) High-Level Code 
	- 2) Syntactic Analysis: converts code to intermediate representation
		- allows for next steps to use *language independent format*
		- *you want to make this as general as possible to adapt to multiple high-level languages*
	- 3) Intermediate Representation 
	- 4) Optimization 
- Back-End
	- 5) Scheduling/Resource Allocation: determines when each operation will execute, and resources are used (simulataneous)
	- 6) Binding/Resource Sharing: maps operations onto physical resources (simultaneous)
	- 7) Controller + Datapath
	- 8) Represent everything in RTL VHDL code
---
### Syntactic Analysis 
- Definition: Analysis of code to verify syntactic correctness 
	- converts code into intermediate representation 
- 2 Steps
	- 1) Lexical Analysis (Lexing)
		- Lexical analysis (lexing) breaks code into series of defined token
		- Token: defined language constructs
		- Example: Take the code below
		```C
		 x = 0
		 if (y < z)
		    x = 1; 
		 ```
		 - Pass code through **Lexical Analysis**
		 - Tokens: ID(x), ASSIGN, INT(0), SEMICOLON, IF, LPAREN, ID(y), LT, ID(z), RPAREN, ID(x), ASSIGN, INT(1), SEMICOLON
		 - Define tokens using regular expressions 
			 - Outputs C code that lexes input 
				 - Common tool is "lex"
				 - Regular Expressions (REGEX) ![[Pasted image 20251015235538.png]]
				 - Will help find / report an error for **legal tokens**
	- 2) Parsing
		- Analyzes token sequence to determine **correct grammatical structure**
			- Languages defined by **context-free grammar**
			- Correct Programs ![[Pasted image 20251022175312.png]]
			- Incorrect Grammar![[Pasted image 20251022175745.png]]
				- Statement has a **complex definition** in most languages
					- Keeping it simple for this language 
		-  Parsing Tools 
			- Define grammar in special language 
				- Automatically creates parser based on grammar 
				- Popular tool is "yacc" - yet-another-compiler-compiler
				- Example functions ![[Pasted image 20251022180314.png]]
					- Pass code above into **"yacc"**
- **Intermediate Representation**
	- Parser converts tokens to intermediate representation 
		- usually, an abstract syntax tree
		- Example ![[Pasted image 20251022180625.png]]
	- Why use intermediate representation? 
		- **Easier to analyze/optimize than source code**
		- Can theoretically be used for all languages 
			- Makes synthesis back end language independent 
				- Can take C, Java, Python, etc and convert it all to the intermediate representation 
	- Different types 
		- Abstract Syntax Tree 
		- Control/Data Flow (CDFG)
		- Sequencing Graph 
			- etc. 
	- We will focus on CDFG
		- Combines control flow graph (CFG) and data flow graph (DFG)
- Control Flow Graphs 
	- **CFG** 
		- Represents control flow dependencies of *basic blocks*
		- **Basic Block:** section of code that executes for beginning to end 
			- I.e. no jumps into or out of block ![[Pasted image 20251022181331.png]]
- Data Flow Graphs
	- **DFG** 
		- Represents data dependencies between operations ![[Pasted image 20251022181503.png]]
- Control/Data Flow Graphs 
	- Combines CFG and DFG 
		- Maintains DFG for each node of CFG 
	- Example ![[Pasted image 20251022181726.png]]
---
## High-Level Synthesis Optimization 

### Synthesis Optimizations 
- After creating CDFG, high-level synthesis optimizes graph 
- **Goals** 
	- Reduce area 
	- Improve latency 
	- Increase parallelism 
	- Reduce power/energy 
- **2 Types** 
	- Data flow optimizations 
	- Control flow optimizations 
---
### Data Flow Optimizations 
- **Tree-Height Reductions**
	- Generally made possible from commutativity, associativity, and distributivity 
	- Example Trees: ![[Pasted image 20251022182335.png]]
- **Operator Strength Reduction**
	- Replacing an expensive ("strong") operation with a faster/smaller one 
	- Common example: replace multiply/divide with shift ![[Pasted image 20251022182621.png]]
- **Constant Propagation**
	- Statically evaluate expressions with constants 
	- Example ![[Pasted image 20251022183014.png]]
- **Function Specialization**
	- Create specialized code for common inputs 
		- Treat common inputs as constants 
		- If inputs not known statically, must include if statement for each call to be specialized function ![[Pasted image 20251022183619.png]]
- **Common sub-expression elimination** 
	- If expression appears more than once, repetitions can be replaced ![[Pasted image 20251022183950.png]]
- **Dead Code Elimination** 
	- Remove code that is never executed 
		- Might be dumb, but comes from constant propagation or function specialization 
	- Elimination: ![[Pasted image 20251022184135.png]]
		- x > 0 does not need a branch if we know that *x will always be positive*
- **Code Motion (Hoisting/Sinking)**
	- Avoid repeated computation 
	- Repetition: ![[Pasted image 20251022184443.png]]
---
### Control Flow Optimizations 
- **Loop Unrolling**
	- Replication body of loop 
		- May increase parallelism
	- Loop Unrolling Example: ![[Pasted image 20251022184833.png]]
- **Function Inclining** 
	- Replace function call with body of function 
		- Common for both SW and HW
		- Replacement Example: ![[Pasted image 20251022185107.png]]
- **Conditional Expansion** 
	- Replace if with logic expression 
		- Executed if/else bodies in parallel 
		- Example: ![[Pasted image 20251022185910.png]]
- **Optimization** ![[Pasted image 20251022190410.png]]