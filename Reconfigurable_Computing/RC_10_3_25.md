## Placement Techniques 
- Placement is an NP-Complete optimization problem 
	- May possible placements - we want best one 
- What is the best solution? 
	- Branch and Bound 
		- not feasible
	- Map to other NP-Complete problem - use heuristic for that problem 
	- Use general optimization heuristics 
		- Simulated annealing (very common)
		- Hill climbing 
	- How to use general optimization heuristics 
		- Cost function represents quality of placement
		- neighboring solution - try new location for CLB
- **Common to map placement to other NP-Complete Problems**
	- Example: Min-Cut Problem 
		- Background: Given a graph, a cut is a set of edges that divides the graph into two (or more) groups 
		- Min-Cut Problem Definition:
			- Find the minimum cut size for a given graph 
		- Similar to *graph bipartitioning* problem 
		- "breaking the FPGA and figuring out how they will communicate"
			- **Optimizing Cutsize becomes a cost function and it minimizes communication**
		- Graph: Nodes are CLBs, Edges are wires
		- Partition divides 
- **KLFM Heuristics**
	- Basic Idea: 
		- Start with initial partition 
		- Iteratively improves cutsize 
			- Cutsize is the number of edges between partitions 
			- Need a size constraint on each region (4 = 4 CLBS in each region)
		- Moves one node at a time 
			- Node that gives the greatest reduction or **least degradation** 
				- Always pick something to move and prioritize improving cutsize 
		- Lock node after moving 
		- Continue moving nodes until all locked or size constraints are violated 
		- Find best partitioning, unlock all nodes
		- Repeat until no improvement found 
- Definition: Map "virtual" CLBs onto physical CLBs, such that routing can maximize clock frequency 
- No way of estimating routing quality - cost function 
	- wire length
		- Typically leads to shorter wires, may cause congestion 
	- Cutsize 
---
## Routing
- Definition: Given a placement and a set of "virtual" connections implement connections using routing resources such that **clock speed is maximized**
	- Figure out how to configure connection boxes and switch boxes most efficiently 
- Another **Optimization Problem**
	- Most solutions are NP-Complete Problems 
---
### Background 
- Routing algorithms are performed in 2 stages 
	- Global and detail routing 
- Global routing determines channels to be used for each connection ("net")
	- Ignores low-level details of C/S boxes 
	- Focuses on finding a short path that minimize connections 
- Detail routing determines low-level connections used by each C/S box 
	- Uses coarse 
---
### Maze Routing
- Input: 
	- Grid structure represents routing resources 
		- Each box represents a terminal or a routing resource 
	- Set of source and destination terminals 
		- Defines end points of each connection 
- Problem Definition: Find the shortest route for each pair of source and destination terminals 
- Lee's Algorithm: 
	- Expansion - Find shortest path from source to destination that avoids used resources 
		- Done using breadth first search 
		- Essentially like Dijkstra's shortest path algorithm
			- May be multiple shortest paths
	- Main Weakness: 
		- **Quality of routing depends on ordering of nets**
		- How do we determine the best ordering?
			- Too many possibilities - not feasible 
- Pathfinder: 
	- Introduced *Negotiated Congestion*
		- ordering independent 
	- During each routing iteration, route nets using shortest path 
		- ignore whether a resource is being used
	- Allows (overuse / congestion) of routing resources 
	- If congestion exists (illegal routing)
		- Update cost of congested resources based on the amount of overuse 
		- Rip-up all routes and reroute all nets 
- Versatile Place&Route (VPR)
	- Takes a description of fabric as input 
		- Describe routing resources 
		- Could potentially be used for many FPGAs - "versatile"
	- 2 variations of VPR 
		- Routability driven - find an implementation that uses fewest routing resources 
			- Optimizes for **bounding box area**
		- Time Driven - maximize clock speed 
	- Placement/routing Technique 
		- Modified version of Pathfinder 
		- Uses **cost function based on fabric description**
---
## Parallelism
- Why are uPs slow? 
	- Von Neumann architecture
		- "Stored-Program" machine 
			- Memory of instructions (and data)
- Problem 2: Von Neumann bottleneck 
	- Constantly reading/writing data for every instruction requires high memory bandwidth 
- Improvements 
	- Increase resources in datapath to execute multiple instructions in parallel
	- VLIW - very long instruction word 
		- Compiler encodes parallelism into "very-long" instructions 
	- Superscalar
		- Architecture determines parallelism at run time - **out of order instruction execution**
	- Both Improvements make the "Von-Neumann Bottleneck" even worse
- Types of Parallelism 
	- Bit-Level 
	- Instruction Level 
---
