## History
- SPLD - Simple Programming Logic Device 
	- Example: 
		- PAL (Programmable Array Logic)
		- PLA (Programmable Logic Array)
	- Basically, 2-level grid of *and* and  *or* gates 
	- Program connections between gates 
		- Initially, uses fuses/PROM
			- Could only be programmed once 
		- GAL (generic array logic) allowed to be reprogrammed using EPROM/EEPROM
			- but took a long time 
		- Implements hundreds of gates, at most 
- CPLD - Complex Programmable Logic Devices
	- Initially, was a group of SPLDs on a single chip 
	- More recent CPLDs combine macrocells/logic blocks
		- Macrocells can implement array logic, or other common combinational and sequential logic functions 
---
## Current/Future Directions 
- FGPA (Field-Programmable Gate Arrays) - mid 1980s 
	- **Misleading name - there is no array of gates** 
	- **Array of fine-grained configurable components** 
	- Currently support millions of gates 
- Coarse-grained RC architectures
	- CGRAs
	- Array of coarse-grained components 
		- Multipliers, DSP units, etc. 
	- Potentially, larger capacity than FPGA
		- It's really good at what it was designed for 
		- But, applications may not map well 
			- Wasted resources
			- Inefficient execution
--- 
## FPGA Architectures
- How can we implement any circuit in an FPGA? 
	- First, focus on combinational logic
	- Example: half adder 
		- combinational logic represented by a truth table 
		- what kind of hardware can we implement a truth table?
	- Implement a truth table in small memories (LUTs)
		- usually SRAM
	- Logic Inputs connect to address inputs 
		- Logic output is memory output ![[Pasted image 20250922030859.png]]
		- Alternatively, could have used a 2-input, 2-output LUT
			- outputs commonly use same inputs 
		- Slightly bigger example: full adder
			- 3-input, 2-output LUT 
	- Why aren't FPGAs just a big LUT?
		- Size of truth table grows exponentially based on # of inputs 
			- 3 inputs = 8 rows, 4 inputs = 16 rows, 5 inputs = 32 rows, etc. 
			- Same number of rows in truth table and LUT
			- LUTs grow exponentially based on # of inputs 
		- Numbers of SRAM bits in LUT = $2^i * o$
			- i = # of inputs, o = # of outputs
			- Example: 64 combinational logic and 1 output would require $2^{64}$ 
				- $1.84 \times 10^{19}$ 
		- Clearly, not feasible to use large LUTs
			- So, how do FPGAs implement logic with many inputs
		- Fortunately, we can map circuits into multiple LUTs 
			- Divide circuit into smaller circuits that fit in LUTs (same # of inputs and outputs)
				- **Technology mapping**
			- Example: 3-input, 2-output LUTs ![[Pasted image 20250922032422.png]]
			- Try to look for the most efficient result
	- What if circuit doesn't map perfectly? 
	- More inputs in LUT than in circuit
		- Truth table handles this problem 
		- Unused inputs are ignored
	- More outputs in LUT than in circuit 
		- Extra outputs simply not used 
			- Space is wasted, so should use multiple outputs whenever possible
	- Important Point 
		- the number of gates in a circuit has no effect on mapping into a LUT 
			- all that maters is the number of inputs and outputs ![[Pasted image 20250922034322.png]]
		- Unfortunately, it isn't common to see large circuits with a few inputs !
--- 
## Sequential Logic 
- Problem: How to handle sequential logic
	- Truth tables won't work
- Possible Solution: 
	- Add a flip-flip to the output of LUT ![[Pasted image 20250922034514.png]]
	- Example: 8-bit register using 3-input, 2-output LUTs 
		- Input: x, Output: y
		- LUT passes inputs to appropriate output (acts like a wire)
	- Isn't it as waste to use LUTs for registers 
		- YES! (when it can be used for something else)
			- Commonly used for pipelined circuits 
				- Example: Pipelined adder
			- Much more efficient circuit to have combinational logic in front of a register