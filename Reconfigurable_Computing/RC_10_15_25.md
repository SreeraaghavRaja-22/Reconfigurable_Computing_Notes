## High-Level Synthesis (Tools)
### Existing FPGA Tool Flow 
- **Register-Transfer (RT) Synthesis**
	- Specify RT structure (muxes, registers, etc)
	- **Pro:** Allows *precise specification*
	- **Con:** *Time consuming, difficult, error prone* 
---
### Motivation
- **Wouldn't it be nice to write high-level code?** 
	- Ratio of C to VHDL developers (10000:1 ?)
		- **Pros:** 
			- *Easier to specify*
			- Modular: separates function from architecture
				- *more portable code*
		- **Cons:**
			- *Slower hardware*
				- programmers could always beat compiler 
					- not the case anymore 
					- No high-level thing can replace RTL code really
		- *Hopefully,* high-level synthesis will catch up to RTL (manual effort)
			- *More challenging than compilation*
				- **Compilation:** *maps behavior* into *assembly instructions*
					- compiler knows the architecture already
				- **High-Level Synthesis:** *creates a custom architecture to execute behavior*
					- Huge hardware exploration space
					- Best solution may include microprocessors
					- Should handle any high-level code 
						- not all code is appropriate for hardware
---
### Steps for High-Level Synthesis 
- First, consider how to manually convert high-level code into circuit 
```
acc = 0; 
for(i = 0; i < 128; i++)
	acc += a[i];
```
- Manual Steps
	- 1) Build **FSM** for controller 
		- Decompose code into states
	- 2) Build **datapath** based on FSM
		- Allocate resources for operations in each state 
		- Determine register inputs 
		- Add outputs 
		- Add control signals 
	- 3) Combine Controller and Datapath
		- identify tradeoffs between different datapaths and see what is most attractive
			- done by High-Level Synthesis
- High-Level Synthesis Steps 
	- **Scheduling:** Determining when to perform each operation 
	- **Resource Allocation:** Allocating resource for each operation
	- **Binding:** Mapping operations onto resources
---
### Basic Idea of High Level Synthesis 
- We take a high-level programming language like C/C++, SystemC, Java, Perl, Python, ImpulseC, etc. 
- We put that code through the **high-level synthesis tool**
- That tool outputs a **custom circuit** in either RTL VHDL description or as **low level as a bit file** 
---
### Main Steps for High-Level Synthesis 
- The **high-level synthesis tool** is very similar to a **compiler** 
- Front-End
	- 1) High-Level Code 
	- 2) Syntactic Analysis: converts code to intermediate representation
		- allows for next steps to use *language independent format*
		- *you want to make this as general as possible to adapt to multiple high-level languages*
	- 3) Intermediate Representation 
	- 4) Optimization 
- Back-End
	- 5) Scheduling/Resource Allocation: determines when each operation will execute, and resources are used (simulataneous)
	- 6) Binding/Resource Sharing: maps operations onto physical resources (simultaneous)
	- 7) Controller + Datapath
	- 8) Represent everything in RTL VHDL code
---
### Syntactic Analysis 
- Definition: Analysis of code to verify syntactic correctness 
	- converts code into intermediate representation 
- 2 Steps
	- 1) Lexical Analysis (Lexing)
		- Lexical analysis (lexing) breaks code into series of defined token
		- Token: defined language constructs
		- Example: Take the code below
		```
		 x = 0
		 if (y < z)
		    x = 1; 
		 ```
		 - Pass code through **Lexical Analysis**
		 - Tokens: ID(x), ASSIGN, INT(0), SEMICOLON, IF, LPAREN, ID(y), LT, ID(z), RPAREN, ID(x), ASSIGN, INT(1), SEMICOLON
		 - Define tokens using regular expressions 
			 - Outputs C code that lexes input 
				 - Common tool is "lex"
				 - Regular Expressions (REGEX) ![[Pasted image 20251015235538.png]]
	- 2) Parsing
		- 
