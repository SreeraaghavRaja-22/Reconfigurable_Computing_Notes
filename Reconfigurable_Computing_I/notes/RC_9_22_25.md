## FPGA Sequential Logic 
- Technology Mapping 
- Problem: How to handle sequential logic
	- Truth tables don't work 
- Possible Solution: 
	- Add FFs to the output of the Truth Table 
	- The LUTs become a wire 
- More common implementation is a pipelined circuit 
- Existing FPGAs don't have flip flop connected to LUT outputs 
- Why not?
	- Flip Flop has to be used 
		- Impossible to have pure combinational logic
	- Adds latency to circuit 
- **Actual Solution:** Configurable Logic Blocks 

---
## Configurable Logic Blocks (CLBs)
- CLBs: the basic FPGA functional unit 
- First issue: How to make the flip-flop optional?
	- Simplest way: use a mux
		- Circuit can now use output from LUT or from FF
		- The select comes from 
- CLBs usually contain more than 1 LUT 
	- Why? 
		- Efficient way of handling common I/O between adjacent LUTs
		- Saves routing resources 
			- Efficient interconnects is vital because the interconnect in FPGAs adds delays and slowness when leaving CLB
	- Example: Ripple-Carry Adder 
		- Each LUT implements 1 full adder 
		- Use efficient connections between LUTs for carry signals 
- CLBs often have specialized connections between adjacent CLBs
	- Further improves carry chains 
	- Avoids routing resources 
- Some commercial CLBs are even more complex 
	- XLINX has CLBs made up of n "slices"
	- Altera has LABs (Logic Array Blocks) 
- Basic Building Block of FPGAs is the CLB
	- Can implement combinational + sequential logic 
	- All circuits consist of both types of logic together 
---
## Reconfigurable Interconnect 
- FPGAs need some way of connecting CLBs together 
	- Reconfigurable Interconnect 
	- But, we can only put fixed wires on a chip 
- Problem 1: how can we make reconfigurable interconnect with fixed wires?
- Problem 2: If FPGA doesn't know which CLBs will be connected, where does it put wires 
- Solution: 
	- Put wires everywhere 
		- Routing wires / routing channels / routing tracks 
			- Channels: each row or column 
			- Tracks/Wires: individual wire connection
- Problem 3: How to connect CLB to wires?
- Solution: Connection box
	- Devices that allows inputs and outputs of CLB to different wires
- Connection Box Characteristics 
	- Flexibility 
		- Number of wires a CLB input/output can connect to
		- Flexibility 2 / Flexibility 3 
	- Topology
		- Specific wires each CLB I/O can connect to 
		- Example: same flexibility, different topology ![[Pasted image 20250922234752.png]]
		- Connection boxes allows CLBs to connect to routing wires 
			- But, that only allows us to move signals along a single wire 
			- Not very useful 
		- Problem 4: How do FPGAs connect wires together?
		- Solution: switch boxes, switch matrices 
			- Connects horizontal and vertical routing channels 
		- Switch Boxes: 
			- Flexibility - defines how many wires a single wire can connect to 
			- Topology - defines which wires can be connected 
				- Planar/subset switch box: only connect tracks with same id/offset 
				- Wilton switch box: connects tracks with different offsets ![[Pasted image 20250923000134.png]]
		- Why do flexibility and topology matter? 
			- Routability: a measure of the number of circuits that can be routed 
				- Higher flexibility = better routability 
				- Wilton switch box topology = better routability 
		- Switch Boxes
			- Short channels: connections between adjacent CLBs
				- leads to congestion
			- Long Channels: useful for connecting CLBs that are separated 
				- Allows for reduced routing delay for non-adjacent CLBs
---
## FPGA Fabrics 
- FPGA layout called a *fabric*
	- 2-dimensional array of CLBs and programmable interconnect
	- Sometimes referred to as an "island style" architecture ![[Pasted image 20250923001519.png]]
	- Can implement any circuit
		- But, should fabric include something else? 
---
## FPGA Memory Components 
- What about memory? 
	- Could use FF's in CLBs to create a memory 
		- Example: create a 1MB memory with: 
			- CLB with a 3-input, 2 output LUT
		- Each CLB = 2 bits of memory (because of 2 outputs)
		- Total CLBs = (1MB * 8bits/byte) / 2 bits/CLB
			- 4 Million CLBs!!!
			- FPGAs commonly have tens of thousands of LUTs
				- Large devices have 100-200k LUTs
				- State-of-the-art devices ~800k LUTs 
			- Even if FPGAs were large enough, using a chip to implement 1 MB of memory is not smart 
		- Conclusion: 
			- Bad idea!! Huge waste of resources!!!
		- Solution 1: Use LUTs for logic or memory 
			- LUTs are small SRAMs, why not use them as memory? 
				- Xilinx refers to as **distribution/distributed** RAM 
				- Intel/Altera refers to as MLABs
		- Solution 2: Include dedicated RAM components in the FPGA fabric
			- Xilinx refers to as Block Ram 
				- Can be single/dual-ported 
				- Can be combined into arbitrary sizes
				- Can be used as FIFO
					- Different clock speeds for reads/writes 
			- Altera has Memory Blocks 
					- M4K: 4k bits of RAM
					- Others: M9K, M20k, M144K
			- LUTs don't have synchronous reads because they are combinational logic 
				- **our memory** can have **asynchronous reads**
		- Fabric with Block Ram 
			- Block Ram can be placed anywhere 
			- Typically, placed in columns of the fabric 
- **Important Question:** How to optimize a circuit for the different types of memory resources in an FPGA?
	-