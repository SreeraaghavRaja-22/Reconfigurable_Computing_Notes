## DSP Components 
- FPGAs are commonly used for DSP apps 
	- makes sense to include **custom DSP units** instead of mapping onto LUTS
		- Custom unit is better (faster/smaller)
	- Example: Xilinx DSP48
		- Includes **multipliers, adders, subtractors, etc**
			- 18x18 multiplication 
			- 48-bit addition/subtraction 
		- Provides efficient way of implementing 
			- Add/subtract/multiply
			- MAC (multiply accumulate)
			- Barrel Shifter 
			- FIR Filter
			- Square root
			- etc. 
	- Altera devices natively support **FPU / FP operations** DSPs 
---
## Example Fabric 
- Existing FPGAs are 2-dimensional arrays of CLBs, DSP, Block RAM, and programmable interconnect
	- Actual layout/placement differs from different FPGAs 
	- Specialized resources tend to be in columns and not rows
---
## Other Resources
- I/O
	- very specialized 
	- communication is a bottleneck 
		- pins don't increase with new FPGAs, but logic does 
	- Trend: high-speed serial transceivers 
		- operate in GHz range
		- comes in serially and get parallelized in chip
- Clock Resources
	- using reconfigurable interconnect for clock introduces timing problems 
		- **skew:** difference in times that a clock arrives at various locations
		- **jitter:** short term variations a clock has from actual time 
	- FPGAs often provided clock trees, both globally and locally 
	- Clock is a **high fan-out signal**
		- connect to many devices 
		- there are distribution networks for the clock so that every component receives it at the same time 
	- If you gate the clock, it will go on the **Reconfigurable Interconnect** instead of the **Clock Distribution Network** 
		- this will make the clock much slower, ruining the design 
		- **Specialized clock gating resources that will gate the clock without putting it on the reconfigurable interconnect**
---
## Example Fabrics
- PCI Express 
	- FPGAs have PCI Express
	- High-Speed standard used to connect internal components of computers 
	- GPUs, SSDs, sound cards, network cards
---
## Programming FPGAs
- How to program/configure FPGA to implement circuit 
	- **Technology Mapping:** mapped a circuit onto FPGA fabric 
		- converting a circuit from on representation to stuff that includes physical components (Gates to LUTs, memory to Block Rams, multiplication to DSP48s)
	- Some way of configuring each component's behavior to match desired outcome 
		- General Idea: for every reconfigurable component, add FFs to control programmable component 
		- How do we specify select to a mux? 
			- we use a configuration/control FF (outside the CLB) as a select 
	- FPGAs are programmed with a **bitfile**
		- File containing all information needed to program FPGA
			- contains bits for control FF 
			- also contains bit to fill LUTs
		- how to get bitfile into FPGA?
			- 10K LUTs
			- Small number of pins 
			- Solution: Shift Registers 
				- make a huge shift register out of all programmable components (LUTs, control FFs))
				- Shift in one bitfile at a time ![[Pasted image 20250929002705.png]]
				- Simple and elegant solution YIPPEEEE
				- Example: ![[Pasted image 20250929002804.png]]
				- FPGAs have a **frozen state** when the FPGA is doing nothing and the bitfile is being shifted in 
			- **Issues with using Shift Registers:**
				- reconfiguring an FPGA is slow 
					- shifting 1 bit at a time is very inefficient 
					- Bitfiles can be greater than 1 MB
					- eliminates one of the main advantages of RC 
						- **Partial Reconfiguration**
						- **With shift registers, entire FPGA has to be reconfigured**
			- **Solutions:**
				- **Different FPGAs allow different regions to be reconfigured**
				- Requires a lot of user effort 
					- need better tools 
---
## FPGA Architecture Tradeoffs
- LUTS with many inputs can implement large circuits efficiently 
	- Why not use LUTs with many inputs?
		- need larger LUTs 
- High Flexibility in routing resources improves routability 
	- Why not just allow all possible connections?
- Answer: architectural tradeoffs
	- Anytime one component increased/improved there is less area for other components 
		- Larger LUTs => less total LUTs, less routing resources
		- More Block RAM => less LUT, less DSPs 
		- More DSPs => less LUTs, less block RAM 
		- etc.
	- **Pareto Optimal Tradeoffs**
	- Given the tradeoffs there will be common questions 
		- How to design best FPGA fabric
			- No overall best 
			- Design fabric based on different domains 
				- DSP will require many DSP units 
				- HPC may require balance of units 
				- Embedded systems may require microprocessors 
			- Xilinx Virtex IV
				- LX: logic intensive apps 
				- SX: signal processing apps 
				- FX: embedded systems apps 
					- had 450MHz PowerPC cores embedded in fabric 
				- Xilinx 7 Series 
					- Artix, Kintex, Virtex
---
## Zynq
- Combines ARM processor with programmable logic (PL)
	- Artix FPGA
	- DRAM Controller
	- PCIe Controller
	- Other peripherals 
---
## Altera Stratix/Arria 10 
- > 1 million LUTs
- Floating-point unit cores in fabric 
- **HyperFlex Interconnect** 
	- Embed flip flops into reconfigurable interconnect 
	- Enables much faster clock speed 